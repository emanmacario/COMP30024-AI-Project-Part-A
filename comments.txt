COMP30024 Artificial Intelligence - Project Part A
Semester 1, 2018.

Written by Emmanuel Macario and James Marshall
Student Numbers: Emmanuel - 831659, James - 728089


Analysis of our Program:

Finding legal move counts:
For calculating the number of available moves for both players,



Finding a legal move sequence:
For calculating the sequence of moves to eliminate all enemy pieces, we have
decided to model the search problem similarly to a single-state problem
formulation. Our model of the problem consists of an initial state, a terminal
test, and actions (moves)

The search algorithm that our program uses is iterative deepening depth-first
search. The branching factor of our tree is equal to the maximum number of valid
moves available for all White pieces, for any valid board configuration. Since
we are only expected to handle a maximum of 5 white pieces
in Part A, the branching factor is 5 * 4 (max possible moves for each piece),
which equals 20. For any normal board configuration, however, the branching
factor could be 12 * 4 = 48, since there will be a maximum of 12 White pieces.

If the condition holds that we will only be given 'valid' board configurations,
configurations i.e. board configurations allowing White pieces to eliminate
black pieces in a maximum of 5 moves, then the maximum search depth will be
equal to d = 5. If we were to be given a board configuration where it was not
possible to eliminate all black pieces, the state space would be infinite, and
hence the maximum search depth would be infinite.





For calculating the number of available moves, what is the time complexity and space
complexity of your program? You should not count the time taken to read the board
configuration from input.

â€¢ For calculating the sequence of moves to eliminate all enemy pieces, how have you
modelled the problem as a search problem? What search algorithm does your
program use? If applicable, what is the branching factor of your search tree? What is
the maximum search depth? Does your algorithm always return the shortest possible
sequence of moves that will eliminate all enemy pieces?


End of question 1
our time complexity is O(n), where n is the number of pieces. We search through
the board to get our dictionaries for search, which would be s^2, where s is the
size of the board, however, this is a constant. We then search through every
piece (n) and for every piece search all of the possible spaces the piece could
move to maximum 8n, leading to a time complexity of O(8n) = O(n).
The space complexity of our available move counter is O(n), where n is the
number of pieces. This is because we store our board state, and we then store
all of the possible moves that each piece, n, can make (maximum 4). This leads
to a space complexity of O(4n) = O(n).

End of Question 2
Yes, our algorithm will always return the shortest possible path as we are
implementing iterative deepening search, with a path cost equal to 1. This will
always be optimal.
